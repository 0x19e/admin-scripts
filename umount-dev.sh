#!/bin/bash
#
# -=[ 0x19e Networks ]=-
#
# Mounts a logical volume containing a whole disk (i.e. multiple partitions)
# Uses kpartx to manage block device mappings
#
# Author: Robert W. Baumgartner <rwb@0x19e.net>
#
DEFAULT_MOUNTPOINT="/media/dev"

hash kpartx 2>/dev/null || { echo >&2 "You need to install kpartx. Aborting."; exit 1; }
hash blkid 2>/dev/null || { echo >&2 "You need to install util-linux. Aborting."; exit 1; }
hash awk 2>/dev/null || { echo >&2 "You need to install awk. Aborting."; exit 1; }

exit_script()
{
  # Default exit code is 1
  local exit_code=1
  local re

  re='^([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'
  if echo "$1" | grep -qE "$re"; then
    exit_code=$1
    shift
  fi

  re='[[:alnum:]]'
  if echo "$@" | grep -iqE "$re"; then
    if [ "$exit_code" -eq 0 ]; then
      echo "INFO: $*"
    else
      echo "ERROR: $*" 1>&2
    fi
  fi

  # Print 'aborting' string if exit code is not 0
  [ "$exit_code" -ne 0 ] && echo "Aborting script..."

  exit "$exit_code"
}

test_arg()
{
  # Used to validate user input
  local arg="$1"
  local argv="$2"

  if [ -z "$argv" ]; then
    if echo "$arg" | grep -qE '^-'; then
      usage "Null argument supplied for option $arg"
    fi
  fi

  if echo "$argv" | grep -qE '^-'; then
    usage "Argument for option $arg cannot start with '-'"
  fi
}

test_path_arg()
{
  # test directory argument
  local arg="$1"
  local argv="$2"

  test_arg "$arg" "$argv"

  if [ -z "$argv" ]; then
    argv="$arg"
  fi

  if [ ! -e "$argv" ]; then
    usage "Specified output path does not exist."
  fi
}

usage()
{
    # Prints out usage and exit.
    sed -e "s/^    //" -e "s|SCRIPT_NAME|$(basename "$0")|" << EOF
    USAGE

    Umount all partitiions for the specified device.
    Used to umount devices mounted with the corresponding mount script.

    SYNTAX
            SCRIPT_NAME [OPTIONS] [ARGUMENT]

    ARGUMENT

     device                   The block device containing partitions to unmount.

    OPTIONS

     -m, --mountpoint <path>  Specify the location to mount partitions to.

     -v, --verbose            Make the script more verbose.
     -h, --help               Prints this usage.

EOF

    exit_script "$@"
}

VERBOSE=""
VERBOSITY=0

check_verbose()
{
  if [ $VERBOSITY -gt 1 ]; then
    VERBOSE="-v"
  fi
}

# process arguments
#echo num params=$#
#saved=("$@")

[ $# -gt 0 ] || usage
while [ $# -gt 0 ]; do
  case "$1" in
    -v|--verbose)
      ((VERBOSITY++))
      check_verbose
      i=$((i+1))
      shift
    ;;
    -m|--mountpoint)
      test_path_arg "$1" "$2"
      shift
      MOUNTPOINT="$2"
      shift
    ;;
    -h|--help)
      usage
    ;;
    *)
      test_arg "$1"
      VOLUME="$1"
      shift
    ;;
  esac
done

# check if superuser
if [[ $EUID -ne 0 ]]; then
   echo >&2 "This script must be run as root."
   exit 1
fi

# Validate device and mountpoint paths
if [ ! -e "${VOLUME}" ]; then
  echo >&2 "ERROR: Volume '${VOLUME}' does not exist."
  exit 1
fi
if [ -z "${MOUNTPOINT}" ]; then
  MOUNTPOINT="${DEFAULT_MOUNTPOINT}"
fi
if [ ! -e "${MOUNTPOINT}" ]; then
  echo >&2 "ERROR: Mount directory not configured; aborting..."
  exit 1
fi

# Adjust mount point
VOLUME_NAME=$(basename "${VOLUME}")
MOUNTPOINT="${MOUNTPOINT}/${VOLUME_NAME}"
if [ ! -e "${MOUNTPOINT}" ]; then
  echo >&2 "WARNING: Mount directory '${MOUNTPOINT}' does not exist."
fi

# Determine mappings that will be generated by kpartx
if ! KPARTX_LIST=$(kpartx -l "${VOLUME}" | awk '{ print $1 }'); then
  echo >&2 "ERROR: Failed to determine kpartx mappings for ${VOLUME}."
  exit 1
fi

declare -a mappings=();
for part in ${KPARTX_LIST}; do
  map="/dev/mapper/${part}"
  mappings=("${mappings[@]}" "${map}")
done

# Process mappings
declare -a unmounted=();
for ((idx=0;idx<=$((${#mappings[@]}-1));idx++)); do
  map=${mappings[$idx]}
  dev=$(readlink -e "${map}")
  mnt=$(basename "${map}")
  if [ ! -b "$dev" ]; then
    echo >&2 "ERROR: '${map}' does not point to a valid block device; skipping..."
  else
    if ! umount "${map}" > /dev/null 2>&1; then
      echo >&2 "ERROR: Failed to unmount ${map}."
    else
      MNT_PATH="${MOUNTPOINT}/${mnt}"
      if [ ! -e "${MNT_PATH}" ]; then
        echo >&2 "WARNING: The path '${MNT_PATH}' does not exist."
      fi
      rm -rf "${MNT_PATH}"
      unmounted=("${unmounted[@]}" "${map}")
    fi
  fi
done

# Unmount and cleanup
for ((idx=0;idx<=$((${#unmounted[@]}-1));idx++)); do
  map=${unmounted[$idx]}
  mnt=$(basename "${map}")
  dir="${MOUNTPOINT}/${mnt}"
  echo "Unmounted '${map}' from '${dir}'"
done

# Delete mappings
echo "Removing ${#mappings[@]} device mapping(s) for '${VOLUME}' ..."
if ! kpartx -ds "${VOLUME}"; then
  echo >&2 "ERROR: Failed to delete mappings for ${VOLUME}."
  exit 1
fi

# Remove top-level mountpoint
if [ -e "${MOUNTPOINT}" ]; then
  echo "Removing top-level mountpoint '${MOUNTPOINT}' ..."
  rm -rvf "${MOUNTPOINT}"
fi

echo "Unmounted volume '${VOLUME}'."

exit 0
